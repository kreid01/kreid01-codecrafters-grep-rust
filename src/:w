use std::collections::VecDeque;

#[derive(Debug, Clone, PartialEq)]
pub enum Token {
    StartAnchor,
    EndAnchor,
    Literal(char),
    AnyChar,
    Digit,
    Word,
    Sequence(Vec<Token>),
    Quantified { atom: Box<Token>, kind: Quantifier },
}

#[derive(Debug, Clone, PartialEq)]
pub enum Quantifier {
    OneOrMore,
    ZeroOrOne,
    None,
}

pub fn lexer(pattern: &str) -> Vec<Token> {
    let mut tokens: Vec<Token> = Vec::new();

    let mut pattern = pattern.chars().peekable();
    while let Some(token) = pattern.next() {
        let token = match token {
            _ => match (token, pattern.next()) {
                ('\\', Some('w')) => Token::Word,
                ('\\', Some('d')) => Token::Digit,
                ('\\', Some(_)) => Token::Word,
                (c, _) => Token::Literal(c),
            },

            _ if token == '^' => Token::StartAnchor,
            _ if token == '$' => Token::EndAnchor,
            _ if token == '.' => Token::AnyChar,
            _ if token == '+' => Token::Quantified {
                atom: Box::new(tokens.pop().unwrap()),
                kind: Quantifier::OneOrMore,
            },
            _ if token == '?' => Token::Quantified {
                atom: Box::new(tokens.pop().unwrap()),
                kind: Quantifier::ZeroOrOne,
            },
            _ => Token::Literal(token),
        };

        tokens.push(token);
    }

    tokens
}

pub fn grep(input: &str, pattern: &str) -> bool {
    let mut tokens = lexer(pattern);
    let chars: Vec<char> = input.chars().collect();
    for start_pos in 0..=chars.len() {
        let mut pos = start_pos;
        if let Some(first) = tokens.first()
            && &Token::StartAnchor == first
        {
            if pos > 0 {
                continue;
            } else {
                tokens.remove(0);
            }
        }
        if match_pattern(&chars, tokens.clone(), &mut pos) {
            return true;
        }
    }
    false
}

pub fn match_pattern(chars: &[char], tokens: Vec<Token>, pos: &mut usize) -> bool {
    let mut tokens: VecDeque<Token> = VecDeque::from(tokens);

    println!("token:{:?}", tokens);

    while let Some(token) = tokens.front() {
        println!("token:{:?},, char{:?}", token, chars);
        let tokens_after: Vec<Token> = tokens.iter().skip(1).cloned().collect();
        let tokens_after_slice: &[Token] = &tokens_after;

        match token {
            Token::Quantified { atom, kind } => {
                match match_quantified(chars, atom, kind, pos, tokens_after_slice) {
                    Ok(()) => {
                        return tokens_after_slice.is_empty() || *pos <= chars.len();
                    }
                    Err(_) => return false,
                }
            }

            _ => {
                let c = match chars.get(*pos) {
                    Some(c) => c,
                    None => return false,
                };

                if match_token(token, c) {
                    *pos += 1;
                    tokens.pop_front();
                } else {
                    return false;
                }
            }
        }
    }

    true
}

fn match_quantified(
    chars: &[char],
    atom: &Token,
    kind: &Quantifier,
    pos: &mut usize,
    tokens_after: &[Token],
) -> Result<(), ()> {
    match kind {
        Quantifier::OneOrMore => match_one_or_more(chars, atom, pos, tokens_after),
        Quantifier::ZeroOrOne => match_zero_or_one(chars, atom, pos, tokens_after),
        Quantifier::None => Err(()),
    }
}

fn match_one_or_more(
    chars: &[char],
    token: &Token,
    pos: &mut usize,
    tokens_after: &[Token],
) -> Result<(), ()> {
    let start_pos = *pos;
    while let Some(&c) = chars.get(*pos) {
        if !match_token(token, &c) {
            break;
        }
        *pos += 1;
    }
    if *pos == start_pos {
        return Err(());
    }

    if tokens_after.is_empty() {
        return Ok(());
    }

    for trial_pos in (start_pos + 1..=*pos).rev() {
        let mut temp_pos = trial_pos;
        if match_pattern(chars, tokens_after.to_vec(), &mut temp_pos) {
            *pos = temp_pos;
            return Ok(());
        }
    }
    Err(())
}

fn match_zero_or_one(
    chars: &[char],
    token: &Token,
    pos: &mut usize,
    tokens_after: &[Token],
) -> Result<(), ()> {
    if *pos >= chars.len() {
        return Ok(());
    }

    if match_token(token, &chars[*pos]) {
        let mut temp_pos = *pos + 1;
        if tokens_after.is_empty() || match_pattern(chars, tokens_after.to_vec(), &mut temp_pos) {
            *pos = temp_pos;
            return Ok(());
        }
    }

    let mut temp_pos = *pos;
    if tokens_after.is_empty() || match_pattern(chars, tokens_after.to_vec(), &mut temp_pos) {
        *pos = temp_pos;
        return Ok(());
    }

    Err(())
}

fn match_token(token: &Token, c: &char) -> bool {
    println!("{:?}, char:{}", token, c);
    match token {
        Token::Digit => digit(c),
        Token::Word => word_characters(c),
        Token::AnyChar => any_char(c),
        Token::Literal(s) => c == s,
        Token::EndAnchor => true,
        Token::StartAnchor => true,
        _ => false,
    }
}

fn any_char(char: &char) -> bool {
    char != &'\n'
}

fn digit(char: &char) -> bool {
    char.is_numeric()
}

fn word_characters(char: &char) -> bool {
    char.is_ascii_alphanumeric() || char == &'_'
}
